{"version":3,"sources":["index.js","face.js","box.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfconv = require(\"@tensorflow/tfjs-converter\");\nvar face_1 = require(\"./face\");\nvar BLAZEFACE_MODEL_URL = 'https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1';\n/**\n * Load blazeface.\n *\n * @param config A configuration object with the following properties:\n *  `maxFaces` The maximum number of faces returned by the model.\n *  `inputWidth` The width of the input image.\n *  `inputHeight` The height of the input image.\n *  `iouThreshold` The threshold for deciding whether boxes overlap too\n * much.\n *  `scoreThreshold` The threshold for deciding when to remove boxes based\n * on score.\n */\nfunction load(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.maxFaces, maxFaces = _c === void 0 ? 10 : _c, _d = _b.inputWidth, inputWidth = _d === void 0 ? 128 : _d, _e = _b.inputHeight, inputHeight = _e === void 0 ? 128 : _e, _f = _b.iouThreshold, iouThreshold = _f === void 0 ? 0.3 : _f, _g = _b.scoreThreshold, scoreThreshold = _g === void 0 ? 0.75 : _g, modelUrl = _b.modelUrl;\n    return __awaiter(this, void 0, void 0, function () {\n        var blazeface, model;\n        return __generator(this, function (_h) {\n            switch (_h.label) {\n                case 0:\n                    if (!(modelUrl != null)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, tfconv.loadGraphModel(modelUrl)];\n                case 1:\n                    blazeface = _h.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, tfconv.loadGraphModel(BLAZEFACE_MODEL_URL, {\n                        fromTFHub: true,\n                    })];\n                case 3:\n                    blazeface = _h.sent();\n                    _h.label = 4;\n                case 4:\n                    model = new face_1.BlazeFaceModel(blazeface, inputWidth, inputHeight, maxFaces, iouThreshold, scoreThreshold);\n                    return [2 /*return*/, model];\n            }\n        });\n    });\n}\nexports.load = load;\nvar face_2 = require(\"./face\");\nexports.BlazeFaceModel = face_2.BlazeFaceModel;\n//# sourceMappingURL=index.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar box_1 = require(\"./box\");\nvar ANCHORS_CONFIG = {\n    'strides': [8, 16],\n    'anchors': [2, 6]\n};\n// `NUM_LANDMARKS` is a fixed property of the model.\nvar NUM_LANDMARKS = 6;\nfunction generateAnchors(width, height, outputSpec) {\n    var anchors = [];\n    for (var i = 0; i < outputSpec.strides.length; i++) {\n        var stride = outputSpec.strides[i];\n        var gridRows = Math.floor((height + stride - 1) / stride);\n        var gridCols = Math.floor((width + stride - 1) / stride);\n        var anchorsNum = outputSpec.anchors[i];\n        for (var gridY = 0; gridY < gridRows; gridY++) {\n            var anchorY = stride * (gridY + 0.5);\n            for (var gridX = 0; gridX < gridCols; gridX++) {\n                var anchorX = stride * (gridX + 0.5);\n                for (var n = 0; n < anchorsNum; n++) {\n                    anchors.push([anchorX, anchorY]);\n                }\n            }\n        }\n    }\n    return anchors;\n}\nfunction decodeBounds(boxOutputs, anchors, inputSize) {\n    var boxStarts = tf.slice(boxOutputs, [0, 1], [-1, 2]);\n    var centers = tf.add(boxStarts, anchors);\n    var boxSizes = tf.slice(boxOutputs, [0, 3], [-1, 2]);\n    var boxSizesNormalized = tf.div(boxSizes, inputSize);\n    var centersNormalized = tf.div(centers, inputSize);\n    var halfBoxSize = tf.div(boxSizesNormalized, 2);\n    var starts = tf.sub(centersNormalized, halfBoxSize);\n    var ends = tf.add(centersNormalized, halfBoxSize);\n    var startNormalized = tf.mul(starts, inputSize);\n    var endNormalized = tf.mul(ends, inputSize);\n    var concatAxis = 1;\n    return tf.concat2d([startNormalized, endNormalized], concatAxis);\n}\nfunction getInputTensorDimensions(input) {\n    return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] :\n        [input.height, input.width];\n}\nfunction flipFaceHorizontal(face, imageWidth) {\n    var flippedTopLeft, flippedBottomRight, flippedLandmarks;\n    if (face.topLeft instanceof tf.Tensor &&\n        face.bottomRight instanceof tf.Tensor) {\n        var _a = tf.tidy(function () {\n            return [\n                tf.concat([\n                    tf.slice(tf.sub(imageWidth - 1, face.topLeft), 0, 1),\n                    tf.slice(face.topLeft, 1, 1)\n                ]),\n                tf.concat([\n                    tf.sub(imageWidth - 1, tf.slice(face.bottomRight, 0, 1)),\n                    tf.slice(face.bottomRight, 1, 1)\n                ])\n            ];\n        }), topLeft = _a[0], bottomRight = _a[1];\n        flippedTopLeft = topLeft;\n        flippedBottomRight = bottomRight;\n        if (face.landmarks != null) {\n            flippedLandmarks = tf.tidy(function () {\n                var a = tf.sub(tf.tensor1d([imageWidth - 1, 0]), face.landmarks);\n                var b = tf.tensor1d([1, -1]);\n                var product = tf.mul(a, b);\n                return product;\n            });\n        }\n    }\n    else {\n        var _b = face.topLeft, topLeftX = _b[0], topLeftY = _b[1];\n        var _c = face.bottomRight, bottomRightX = _c[0], bottomRightY = _c[1];\n        flippedTopLeft = [imageWidth - 1 - topLeftX, topLeftY];\n        flippedBottomRight = [imageWidth - 1 - bottomRightX, bottomRightY];\n        if (face.landmarks != null) {\n            flippedLandmarks =\n                face.landmarks.map(function (coord) { return ([\n                    imageWidth - 1 - coord[0],\n                    coord[1]\n                ]); });\n        }\n    }\n    var flippedFace = {\n        topLeft: flippedTopLeft,\n        bottomRight: flippedBottomRight\n    };\n    if (flippedLandmarks != null) {\n        flippedFace.landmarks = flippedLandmarks;\n    }\n    if (face.probability != null) {\n        flippedFace.probability = face.probability instanceof tf.Tensor ?\n            face.probability.clone() :\n            face.probability;\n    }\n    return flippedFace;\n}\nfunction scaleBoxFromPrediction(face, scaleFactor) {\n    return tf.tidy(function () {\n        var box;\n        if (face.hasOwnProperty('box')) {\n            box = face.box;\n        }\n        else {\n            box = face;\n        }\n        return tf.squeeze(box_1.scaleBox(box, scaleFactor).startEndTensor);\n    });\n}\nvar BlazeFaceModel = /** @class */ (function () {\n    function BlazeFaceModel(model, width, height, maxFaces, iouThreshold, scoreThreshold) {\n        this.blazeFaceModel = model;\n        this.width = width;\n        this.height = height;\n        this.maxFaces = maxFaces;\n        this.anchorsData = generateAnchors(width, height, ANCHORS_CONFIG);\n        this.anchors = tf.tensor2d(this.anchorsData);\n        this.inputSizeData = [width, height];\n        this.inputSize = tf.tensor1d([width, height]);\n        this.iouThreshold = iouThreshold;\n        this.scoreThreshold = scoreThreshold;\n    }\n    BlazeFaceModel.prototype.getBoundingBoxes = function (inputImage, returnTensors, annotateBoxes) {\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, detectedOutputs, boxes, scores, savedConsoleWarnFn, boxIndicesTensor, boxIndices, boundingBoxes, originalHeight, originalWidth, scaleFactor, annotatedBoxes, _loop_1, i;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = tf.tidy(function () {\n                            var resizedImage = tf.image.resizeBilinear(inputImage, [_this.width, _this.height]);\n                            var normalizedImage = tf.mul(tf.sub(tf.div(resizedImage, 255), 0.5), 2);\n                            // [1, 897, 17] 1 = batch, 897 = number of anchors\n                            var batchedPrediction = _this.blazeFaceModel.predict(normalizedImage);\n                            var prediction = tf.squeeze(batchedPrediction);\n                            var decodedBounds = decodeBounds(prediction, _this.anchors, _this.inputSize);\n                            var logits = tf.slice(prediction, [0, 0], [-1, 1]);\n                            var scores = tf.squeeze(tf.sigmoid(logits));\n                            return [prediction, decodedBounds, scores];\n                        }), detectedOutputs = _a[0], boxes = _a[1], scores = _a[2];\n                        savedConsoleWarnFn = console.warn;\n                        console.warn = function () { };\n                        boxIndicesTensor = tf.image.nonMaxSuppression(boxes, scores, this.maxFaces, this.iouThreshold, this.scoreThreshold);\n                        console.warn = savedConsoleWarnFn;\n                        return [4 /*yield*/, boxIndicesTensor.array()];\n                    case 1:\n                        boxIndices = _b.sent();\n                        boxIndicesTensor.dispose();\n                        boundingBoxes = boxIndices.map(function (boxIndex) { return tf.slice(boxes, [boxIndex, 0], [1, -1]); });\n                        if (!!returnTensors) return [3 /*break*/, 3];\n                        return [4 /*yield*/, Promise.all(boundingBoxes.map(function (boundingBox) { return __awaiter(_this, void 0, void 0, function () {\n                                var vals;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, boundingBox.array()];\n                                        case 1:\n                                            vals = _a.sent();\n                                            boundingBox.dispose();\n                                            return [2 /*return*/, vals];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        boundingBoxes = _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        originalHeight = inputImage.shape[1];\n                        originalWidth = inputImage.shape[2];\n                        if (returnTensors) {\n                            scaleFactor = tf.div([originalWidth, originalHeight], this.inputSize);\n                        }\n                        else {\n                            scaleFactor = [\n                                originalWidth / this.inputSizeData[0],\n                                originalHeight / this.inputSizeData[1]\n                            ];\n                        }\n                        annotatedBoxes = [];\n                        _loop_1 = function (i) {\n                            var boundingBox = boundingBoxes[i];\n                            var annotatedBox = tf.tidy(function () {\n                                var box = boundingBox instanceof tf.Tensor ?\n                                    box_1.createBox(boundingBox) :\n                                    box_1.createBox(tf.tensor2d(boundingBox));\n                                if (!annotateBoxes) {\n                                    return box;\n                                }\n                                var boxIndex = boxIndices[i];\n                                var anchor;\n                                if (returnTensors) {\n                                    anchor = tf.slice(_this.anchors, [boxIndex, 0], [1, 2]);\n                                }\n                                else {\n                                    anchor = _this.anchorsData[boxIndex];\n                                }\n                                var landmarks = tf.reshape(tf.squeeze(tf.slice(detectedOutputs, [boxIndex, NUM_LANDMARKS - 1], [1, -1])), [NUM_LANDMARKS, -1]);\n                                var probability = tf.slice(scores, [boxIndex], [1]);\n                                return { box: box, landmarks: landmarks, probability: probability, anchor: anchor };\n                            });\n                            annotatedBoxes.push(annotatedBox);\n                        };\n                        for (i = 0; i < boundingBoxes.length; i++) {\n                            _loop_1(i);\n                        }\n                        boxes.dispose();\n                        scores.dispose();\n                        detectedOutputs.dispose();\n                        return [2 /*return*/, {\n                                boxes: annotatedBoxes,\n                                scaleFactor: scaleFactor\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Returns an array of faces in an image.\n     *\n     * @param input The image to classify. Can be a tensor, DOM element image,\n     * video, or canvas.\n     * @param returnTensors (defaults to `false`) Whether to return tensors as\n     * opposed to values.\n     * @param flipHorizontal Whether to flip/mirror the facial keypoints\n     * horizontally. Should be true for videos that are flipped by default (e.g.\n     * webcams).\n     * @param annotateBoxes (defaults to `true`) Whether to annotate bounding\n     * boxes with additional properties such as landmarks and probability. Pass in\n     * `false` for faster inference if annotations are not needed.\n     *\n     * @return An array of detected faces, each with the following properties:\n     *  `topLeft`: the upper left coordinate of the face in the form `[x, y]`\n     *  `bottomRight`: the lower right coordinate of the face in the form `[x, y]`\n     *  `landmarks`: facial landmark coordinates\n     *  `probability`: the probability of the face being present\n     */\n    BlazeFaceModel.prototype.estimateFaces = function (input, returnTensors, flipHorizontal, annotateBoxes) {\n        if (returnTensors === void 0) { returnTensors = false; }\n        if (flipHorizontal === void 0) { flipHorizontal = false; }\n        if (annotateBoxes === void 0) { annotateBoxes = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, width, image, _b, boxes, scaleFactor;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = getInputTensorDimensions(input), width = _a[1];\n                        image = tf.tidy(function () {\n                            if (!(input instanceof tf.Tensor)) {\n                                input = tf.browser.fromPixels(input);\n                            }\n                            return tf.expandDims(tf.cast(input, 'float32'), 0);\n                        });\n                        return [4 /*yield*/, this.getBoundingBoxes(image, returnTensors, annotateBoxes)];\n                    case 1:\n                        _b = _c.sent(), boxes = _b.boxes, scaleFactor = _b.scaleFactor;\n                        image.dispose();\n                        if (returnTensors) {\n                            return [2 /*return*/, boxes.map(function (face) {\n                                    var scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                    var normalizedFace = {\n                                        topLeft: tf.slice(scaledBox, [0], [2]),\n                                        bottomRight: tf.slice(scaledBox, [2], [2])\n                                    };\n                                    if (annotateBoxes) {\n                                        var _a = face, landmarks = _a.landmarks, probability = _a.probability, anchor = _a.anchor;\n                                        var normalizedLandmarks = tf.mul(tf.add(landmarks, anchor), scaleFactor);\n                                        normalizedFace.landmarks = normalizedLandmarks;\n                                        normalizedFace.probability = probability;\n                                    }\n                                    if (flipHorizontal) {\n                                        normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                    }\n                                    return normalizedFace;\n                                })];\n                        }\n                        return [2 /*return*/, Promise.all(boxes.map(function (face) { return __awaiter(_this, void 0, void 0, function () {\n                                var scaledBox, normalizedFace, boxData, _a, landmarkData, boxData, probabilityData, anchor_1, _b, scaleFactorX_1, scaleFactorY_1, scaledLandmarks;\n                                var _this = this;\n                                return __generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            scaledBox = scaleBoxFromPrediction(face, scaleFactor);\n                                            if (!!annotateBoxes) return [3 /*break*/, 2];\n                                            return [4 /*yield*/, scaledBox.array()];\n                                        case 1:\n                                            boxData = _c.sent();\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2)\n                                            };\n                                            return [3 /*break*/, 4];\n                                        case 2: return [4 /*yield*/, Promise.all([face.landmarks, scaledBox, face.probability].map(function (d) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                                return [2 /*return*/, d.array()];\n                                            }); }); }))];\n                                        case 3:\n                                            _a = _c.sent(), landmarkData = _a[0], boxData = _a[1], probabilityData = _a[2];\n                                            anchor_1 = face.anchor;\n                                            _b = scaleFactor, scaleFactorX_1 = _b[0], scaleFactorY_1 = _b[1];\n                                            scaledLandmarks = landmarkData\n                                                .map(function (landmark) { return ([\n                                                (landmark[0] + anchor_1[0]) * scaleFactorX_1,\n                                                (landmark[1] + anchor_1[1]) * scaleFactorY_1\n                                            ]); });\n                                            normalizedFace = {\n                                                topLeft: boxData.slice(0, 2),\n                                                bottomRight: boxData.slice(2),\n                                                landmarks: scaledLandmarks,\n                                                probability: probabilityData\n                                            };\n                                            box_1.disposeBox(face.box);\n                                            face.landmarks.dispose();\n                                            face.probability.dispose();\n                                            _c.label = 4;\n                                        case 4:\n                                            scaledBox.dispose();\n                                            if (flipHorizontal) {\n                                                normalizedFace = flipFaceHorizontal(normalizedFace, width);\n                                            }\n                                            return [2 /*return*/, normalizedFace];\n                                    }\n                                });\n                            }); }))];\n                }\n            });\n        });\n    };\n    return BlazeFaceModel;\n}());\nexports.BlazeFaceModel = BlazeFaceModel;\n//# sourceMappingURL=face.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nexports.disposeBox = function (box) {\n    box.startEndTensor.dispose();\n    box.startPoint.dispose();\n    box.endPoint.dispose();\n};\nexports.createBox = function (startEndTensor) { return ({\n    startEndTensor: startEndTensor,\n    startPoint: tf.slice(startEndTensor, [0, 0], [-1, 2]),\n    endPoint: tf.slice(startEndTensor, [0, 2], [-1, 2])\n}); };\nexports.scaleBox = function (box, factors) {\n    var starts = tf.mul(box.startPoint, factors);\n    var ends = tf.mul(box.endPoint, factors);\n    var newCoordinates = tf.concat2d([starts, ends], 1);\n    return exports.createBox(newCoordinates);\n};\n//# sourceMappingURL=box.js.map"]}